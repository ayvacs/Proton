{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Proton","text":"<p>A flexible and powerful UI library for Roblox that enables for easy instance creation and integration of functionality.</p> <pre><code>local MyGui = new \"ScreenGui\" {\n    [\"Name\"] = \"My Gui\",\n    [\"Parent\"] = LocalPlayer.PlayerGui,\n    [\"Children\"] = {\n        new \"TextButton\" {\n            [\"Size\"] = UDim2.new(0, 250, 0, 100),\n            [\"Text\"] = \"Click me to do something cool\",\n            [\"*MouseButton1Click\"] = (function()\n                print(\"Left mouse button clicked!\")\n            end)\n        }\n    },\n}\n</code></pre>"},{"location":"#intro-to-proton-syntax","title":"Intro to Proton Syntax","text":"<p>Proton's syntax essentially boils down to:</p> <pre><code>local myInstance = new \"Part\" { --[[ properties ]] }\n</code></pre> <p>The <code>new</code> function creates an instance of the specified <code>ClassName</code> and applies the given Properties.</p> <p>However, the Properties table has the capacity for numerous additional functionalities, i.e. to connect events and parent other instances. This significantly reduces the boilerplate code, making your code less verbose and more readable.</p>"},{"location":"#comparison-of-proton-and-vanilla-luau","title":"Comparison of Proton and Vanilla Luau","text":""},{"location":"#proton_1","title":"Proton","text":"<pre><code>local SGui = new \"ScreenGui\" {\n    [\"Parent\"] = LocalPlayer.PlayerGui,\n    [\"Child\"] = new \"TextButton\" {\n        [\"Size\"] = UDim2.new(0, 250, 0, 100),\n        [\"Text\"] = \"Mouse over me!\",\n        [\"*MouseButton1Down\"] = function(x, y)\n            print(\"Mouse down at \" .. x .. \", \" .. y .. \"...\")\n        end,\n        [\"*MouseButton1Up\"] = function(x, y)\n            print(\"...and up at \" .. x .. \", \" .. y .. \"!\")\n        end\n    }\n}\n</code></pre>"},{"location":"#equivalent-vanilla-luau-code","title":"Equivalent vanilla Luau code","text":"<pre><code>local SGui = Instance.new(\"ScreenGui\")\nSGui.Parent = LocalPlayer.PlayerGui\n\nlocal TextButton = Instance.new(\"TextButton\")\nTextButton.Parent = SGui\nTextButton.Size = UDim2.new(0, 250, 0, 100)\nTextButton.Text = \"Mouse over me!\"\n\nTextButton.MouseButton1Down:Connect(function(x, y)\n    print(\"Mouse down at \" .. x .. \", \" .. y .. \"...\")\nend)\n\nTextButton.MouseButton1Up:Connect(function(x, y)\n    print(\"...and up at \" .. x .. \", \" .. y .. \"!\")\nend)\n</code></pre> <p>The two code snippets perform identical functions, but notice how the Proton code is significantly less wordy and much more readable the than vanilla Luau code.</p>"},{"location":"#syntax-documentation","title":"Syntax Documentation","text":"<p>On this introduction page you observed how Proton can be used to easily apply functions and parent instances.</p> <p>You can learn more about Proton's syntax on the syntax tutorial page.</p>"},{"location":"#installation","title":"Installation","text":"<p>Learn how to install Proton on the installation guide.</p>"},{"location":"installation/","title":"Installation","text":"<p>Installing Proton is just as easy as using it. You can either download a precompiled build (recommended for most users) or build it yourself (recommended only for developers)</p>"},{"location":"installation/#download-a-precompiled-build-recommended-for-most-users","title":"Download a precompiled build (recommended for most users)","text":"<p>Head to the releases page where you can see the latest Proton release. </p> <p></p> <p>Simply click the Proton.rbxm file and download it to your computer. After, drag it to your Roblox Studio window. A <code>ModuleScript</code> named Proton will be inserted to your game; parent it anywhere you'd like, but we suggest <code>ReplicatedStorage</code>.</p>"},{"location":"installation/#build-it-yourself-recommended-only-for-developers","title":"Build it yourself (recommended only for developers)","text":"<p>Installing Rojo</p> <p>To build it yourself, you will need to install Rojo, the tool used by Proton developers to work on the project in VS Code.</p> <p>After opening a new game and starting the Rojo server on both VS Code and Roblox Studio, simply save the Proton <code>ModuleScript</code> in <code>ReplicatedStorage</code> to your computer as a <code>.rbxm</code> file. You can then use this compiled build in any game.</p>"},{"location":"installation/#after-installation","title":"After installation","text":"<p>After installation, you can <code>require</code> Proton and begin to use it.</p> <pre><code>local Proton = require( game:GetService(\"ReplicatedStorage\").Proton ) -- replace this with the path to your Proton installation\n\nlocal new = Proton.require(\"new\")\n</code></pre>"},{"location":"tutorials/events/","title":"Proton Events","text":"<p>When creating an Instance with <code>Proton.new()</code> you can easily connect an event by simply including the event's name in the Properties table, appended with an asterisk (*).</p> <pre><code>new \"ClassName\" {\n    [\"*EventName\"] = function()\n        -- Event code goes here!\n    end\n}\n</code></pre> <p>Here's a real-world example:</p> <pre><code>new \"TextButton\" {\n    [\"*MouseButton1Down\"] = function(x, y)\n        print(\"Mouse down at \" .. x .. \", \" .. y .. \"!\")\n    end\n}\n</code></pre> <p>You can alternatively connect multiple functions to a single event by using the \"Events\" special property.</p> <pre><code>new \"TextButton\" {\n    [\"*MouseButton1Click\"] = (function()\n        print(\"Left mouse button clicked (event 1)\")\n    end),\n\n    [\"Events\"] = {\n        { \"MouseButton1Click\", function()\n            print(\"Left mouse button clicked (event 2)\")\n        end },\n        { \"MouseButton2Down\", function(x, y)\n            print(\"Right mouse button down at \" .. x .. \", \" .. y .. \" (event 3)\")\n        end },\n        { \"MouseButton2Down\", function(x, y)\n            print(\"Right mouse button down at \" .. x .. \", \" .. y .. \" (event 4)\")\n        end }\n    }\n}\n</code></pre>"},{"location":"tutorials/observers/","title":"Value Observers","text":"<p>Observers allow you to detect when values are updated. They receive the new value and the previous value as parameters. A value can have any number of parameters.</p> <pre><code>local value = Proton.require(\"value\")\nlocal observer = Proton.require(\"observer\")\n\n\nlocal health = value.new(100, \"number\", \"Health\")\n\n\nobserver.new(health, function(newHealth, previousHealth)\n\n    if newHealth &lt; previousHealth then\n        print(\"Ow! I took \" .. (previousHealth - newHealth) .. \" damage!\")\n    else\n        print(\"I was healed by \" .. (newHealth - previousHealth) .. \" points!\")\n    end\n\nend)\n\nhealth:increment(-10)   -- Ow! I took 10 damage!\nhealth:increment(5)     -- I was healed by 5 points!\nhealth:increment(0)\n</code></pre> <p>Observers will only function when the value is changed to a new, unique value. This means that, in both of the following code snippets, the observer will never function.</p> <pre><code>local name = value.new(\"John\")\nname:set(\"John\")\n</code></pre> <pre><code>local age = value.new(20, \"number\")\nage:increment(0)\n</code></pre>"},{"location":"tutorials/observers/#observer-validation","title":"Observer Validation","text":"<p>By default, observers will function any time the value is changed to a new value, regardless of what that value is. If we want to set up a validation check so that we can choose whether or not the observer should function based on the new and previous value, we can pass a third argument to <code>observer.new</code> as a function that returns <code>true</code> when the observer should be triggered.</p> <p>For instance, here's an example of a two-player game system that notifies the player when it's their turn:</p> <pre><code>local turnNumber = value.new(0)\n\n\nobserver.new(\n    turnNumber,\n    function(turn, prevTurn)\n        print(\"It's your turn!\")\n    end,\n    function(turn, prevTurn)\n        return (turn % 2 == 0)\n    end\n)\n\nturnNumber:increment(1)\nturnNumber:increment(1) -- It's your turn!\nturnNumber:increment(1)\nturnNumber:increment(1) -- It's your turn!\nturnNumber:increment(1)\nturnNumber:increment(1) -- It's your turn!\n</code></pre>"},{"location":"tutorials/observers/#disconnecting-observers","title":"Disconnecting Observers","text":"<p>Observers can be disconnected by calling <code>:disconnect()</code>.</p> <pre><code>local name = value.new(\"John\")\nlocal obs = observer.new(name, function(newName, previousName)\n    print(\"My name changed to \" .. newName .. \"!\")\nend)\n\nname:set(\"Jonas\")   -- My name changed to Jonas!\n\nobs:disconnect()\n\nname:set(\"John\")\nprint(name:get())   -- John\n\n-- The value of \"name\" was still set to \"John\", but since the observer has been disconnected, it won't be printed.\n</code></pre>"},{"location":"tutorials/special-properties/","title":"Proton Special Properties","text":"<p>Proton's \"special properties\" allow you to easily expand the functionality of your Proton Instances when creating them.</p> <p>For instance, the <code>Child</code> and <code>Children</code> special properties allow you to easily parent new or existing Instances.</p> <pre><code>local txtBtn = new \"TextButton\" {}\n\nnew \"ScreenGui\" {\n    [\"Name\"] = \"My UI\",\n    [\"Children\"] = {\n        txtBtn,\n        new(\"Frame\"){}\n    },\n    [\"Child\"] = new \"TextLabel\" {}\n}\n</code></pre>"},{"location":"tutorials/syntax/","title":"Proton Syntax Guide","text":"<p>As you (probably) read on the homepage, Proton's syntax essentially boils down to the <code>new</code> function, which creates an instance of the specified <code>ClassName</code> and applies the given Properties.</p> <pre><code>local myInstance = new \"Part\" { --[[ properties ]] }\n</code></pre> <p>However, the Properties table has the capacity for numerous additional functionalities, i.e. to connect events and parent other instances. This significantly reduces the boilerplate code, making your code less verbose and more readable.</p>"},{"location":"tutorials/syntax/#import-the-new-function","title":"Import the <code>new</code> function","text":"<p>Once you install Proton, import the <code>new</code> function as such:</p> <pre><code>local Proton = require( game:GetService(\"ReplicatedStorage\").Proton ) -- replace this with the path to your Proton installation\n\nlocal new = Proton.require(\"new\")\n</code></pre> <p>What is <code>Proton.require</code>?</p> <p>The <code>Proton.require</code> function allows you to import Proton's modules. Note that it is separate from Roblox's global <code>require</code> function.</p>"},{"location":"tutorials/values/","title":"Proton Values","text":"<p>A Value object is a sort of storage container for a variable. Values allow you to restrict types and lock the value from being changed.</p> <p>Values are created using the <code>value.new()</code> function. Values are read with the <code>:get()</code> method and updated with the <code>:set()</code> method.</p> <pre><code>local value = Proton.require(\"value\")\n\nlocal myValue = value.new(\"foo\")\nprint(myValue:get())    -- foo\n\nmyValue:set(\"bar\")\nprint(myValue:get())    -- bar\n</code></pre>"},{"location":"tutorials/values/#increment","title":"Increment","text":"<p>Values can be incremented by calling <code>:increment()</code>. This has the expected result for all Roblox engine data types.</p> <pre><code>local health = value.new(100)\nhealth:increment(-10)\nprint(health:get()) -- 90\n\n\nlocal size = value.new(UDim2.new(1, 0, 1, 0))\nsize:increment(UDim2.new(0, 0, 0, 200))\nprint(size:get())   -- {1, 0}, {1, 200}\n\n\nlocal name = value.new(\"John\")\nname:increment(\" Smith\")\nprint(name:get())   -- John Smith\n</code></pre>"},{"location":"tutorials/values/#type-restriction","title":"Type restriction","text":"<p>You can optionally restrict the type by passing the type name as the second parameter.</p> <pre><code>local aStringValue = value.new(\"foo\", \"string\")\n\naStringValue:set(\"bar\")\nprint(aStringValue:get())   -- bar\n\naStringValue:set(1337)      -- [Proton] Could not set this value! (\"1337\" is not of type string)\nprint(aStringValue:get())   -- bar\n</code></pre> <p>As you can see in the above example, attempting to set a restricted type to a value of a different type will print a warning without ending the thread.</p> <p>Valid type names</p> <p>The type name should be the result of the <code>typeof()</code> function. For instance, since <code>typeof(15)</code> returns <code>number</code>, the type name is also \"number\".</p>"},{"location":"tutorials/values/#locking","title":"Locking","text":"<p>You can lock a value (disable the value from being updated by any script) by calling <code>:lock()</code>. You can unlock it with <code>:unlock()</code>.</p> <pre><code>local myValue = value.new(\"foo\")\n\nprint(myValue:get())    -- foo\n\nmyValue:lock()\n\nmyValue:set(\"bar\")      -- [Proton] This value is locked!\nprint(myValue:get())    -- foo\n\nmyValue:unlock()\n\nmyValue:set(\"bar\")\nprint(myValue:get())    -- bar\n</code></pre> <p>Attempting to update a locked value will print a warning without ending the thread.</p>"},{"location":"tutorials/values/#naming","title":"Naming","text":"<p>You can opt to give a value a name by including the name as the third parameter to <code>value.new()</code>. This will help you identify values in error messages, aiding you track down the root cause of potential errors. This has no effect outside of error logging.</p> <pre><code>local health = value.new(100, \"number\", \"Health\")\n\nhealth:lock()\nhealth:set(90)      -- [Proton] Health is locked!\n\nhealth:unlock()\nhealth:set(\"bar\")   -- [Proton] Could not set the value of Health! (\"bar\" is not of type number)\n</code></pre>"}]}